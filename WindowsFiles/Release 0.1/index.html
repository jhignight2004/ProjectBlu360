<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>WebUSB Xbox 360 → ViGEm Bridge</title>
    <style>
      body {
        font-family: system-ui, sans-serif;
        background-color: #1e1e1e;
        color: #ffffff;
      }
      button {
        margin-right: 8px;
      }
      pre {
        background: #111;
        color: #0f0;
        padding: 12px;
        border-radius: 8px;
        max-height: 40vh;
        overflow: auto;
        margin: 8px 0;
      }
      .row {
        margin: 10px 0;
      }
      input {
        width: 340px;
      }
      .dim {
        opacity: 0.75;
      }
      code {
        background: #404040;
        padding: 2px 6px;
        border-radius: 6px;
      }
      .grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .card {
        border: 1px solid #404040;
        border-radius: 10px;
        padding: 10px;
      }
      .mono {
        font-family:
          ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
      }
    </style>
  </head>
  <body>
    <div class="row">
      <button id="connect">Connect Xbox 360 Wireless Controller</button>
      <button id="disconnect" disabled>Disconnect</button>
    </div>

    <div class="row">
      <label class="dim">Bridge WebSocket:</label>
      <input id="wsurl" value="ws://127.0.0.1:8765/ws/" />
      <button id="wsconnect">Connect WS</button>
      <span id="wsstatus" class="dim">WS: disconnected</span>
    </div>

    <div class="row">
      <label class="dim"
        >Make sure you use Zadig to install the WinUSB driver!</label
      >
    </div>

    <div class="row">
      <label class="dim">
        Note: Browsers can sometimes throttle background tabs.
      </label>
    </div>

    <div class="row dim">Vendor/Product: <code id="vp"></code></div>

    <div class="grid">
      <div class="card">
        <div class="dim">Log</div>
        <pre id="out"></pre>
      </div>

      <div class="card">
        <div class="dim">Decoded state (live)</div>
        <div id="liveLine" class="mono dim"></div>
        <div id="rate" class="mono dim" style="margin-top: 6px"></div>
        <pre id="state"></pre>
      </div>
    </div>

    <script>
      // 360 VID and PID
      const VID = 0x045e;
      const PID = 0x028f;

      const USB_INTERFACE = 0;

      // --- UI helpers ---
      const out = document.getElementById("out");
      const statePre = document.getElementById("state");
      const liveLine = document.getElementById("liveLine");
      const rateEl = document.getElementById("rate");

      const log = (s) => {
        out.textContent += s + "\n";
        out.scrollTop = out.scrollHeight;
      };

      document.getElementById("vp").textContent =
        `VID=0x${VID.toString(16).padStart(4, "0")} PID=0x${PID.toString(16).padStart(4, "0")}`;

      function fmt(n, digits = 3) {
        return (Number.isFinite(n) ? n : 0).toFixed(digits);
      }

      function renderState(state) {
        // Pretty JSON
        statePre.textContent = JSON.stringify(state, null, 2);

        // Compact one-liner
        const b = state.buttons;
        const a = state.axes;

        const pressed = [];
        if (b.a) pressed.push("A");
        if (b.b) pressed.push("B");
        if (b.x) pressed.push("X");
        if (b.y) pressed.push("Y");
        if (b.lb) pressed.push("LB");
        if (b.rb) pressed.push("RB");
        if (b.back) pressed.push("Back");
        if (b.start) pressed.push("Start");
        if (b.ls) pressed.push("LS");
        if (b.rs) pressed.push("RS");
        if (b.guide) pressed.push("Guide");
        if (b.up) pressed.push("D↑");
        if (b.down) pressed.push("D↓");
        if (b.left) pressed.push("D←");
        if (b.right) pressed.push("D→");

        liveLine.textContent =
          `LX ${fmt(a.lx)}  LY ${fmt(a.ly)}  RX ${fmt(a.rx)}  RY ${fmt(a.ry)}  ` +
          `LT ${fmt(a.lt, 3)}  RT ${fmt(a.rt, 3)}  |  ` +
          `Buttons: ${pressed.length ? pressed.join(" ") : "(none)"}`;
      }

      // --- WebSocket to local bridge ---
      let ws = null;
      const wsStatusEl = document.getElementById("wsstatus");
      const wsUrlEl = document.getElementById("wsurl");

      function setWsStatus() {
        const st = ws ? ws.readyState : -1;
        const s =
          st === WebSocket.CONNECTING
            ? "connecting"
            : st === WebSocket.OPEN
              ? "connected"
              : st === WebSocket.CLOSING
                ? "closing"
                : st === WebSocket.CLOSED
                  ? "disconnected"
                  : "disconnected";
        wsStatusEl.textContent = "WS: " + s;
      }

      function connectWS() {
        const url = wsUrlEl.value.trim();
        if (!url) {
          log("WS Error: empty URL");
          return;
        }

        if (
          ws &&
          (ws.readyState === WebSocket.OPEN ||
            ws.readyState === WebSocket.CONNECTING)
        ) {
          log("WS: already open/connecting");
          return;
        }

        try {
          ws = new WebSocket(url);
          setWsStatus();

          ws.onopen = () => {
            setWsStatus();
            log("WS: connected");
          };
          ws.onclose = () => {
            setWsStatus();
            log("WS: closed");
          };
          ws.onerror = () => {
            setWsStatus();
            log("WS: error");
          };
        } catch (e) {
          log("WS Error: " + (e && e.message ? e.message : String(e)));
        }
      }

      // Send logic: keep newest only, drop if WS is backing up, and cap send rate.
      let lastSentAt = performance.now();
      function wsSendLatest(state) {
        if (!ws || ws.readyState !== WebSocket.OPEN) return false;

        // If bufferedAmount grows, we're behind. Drop frames to avoid "bursty" stale inputs.
        if (ws.bufferedAmount > 128 * 1024) return false;

        // Cap send rate (prevents burst spam when tab regains focus)
        const now = performance.now();
        if (now - lastSentAt < 4) return false; // ~250 Hz max
        lastSentAt = now;

        ws.send(JSON.stringify(state));
        return true;
      }

      document.getElementById("wsconnect").onclick = connectWS;
      setWsStatus();

      // --- WebUSB ---
      let dev = null;
      let running = false;

      function s16le(u8, off) {
        const v = (u8[off] | (u8[off + 1] << 8)) & 0xffff;
        return v & 0x8000 ? v - 0x10000 : v;
      }

      function u32le(u8, off) {
        return (
          (u8[off] |
            (u8[off + 1] << 8) |
            (u8[off + 2] << 16) |
            (u8[off + 3] << 24)) >>>
          0
        );
      }

      // Normalize:
      //  sticks: int16 -> [-1..+1]
      //  triggers: uint8 -> [0..1]
      function normStick(s16) {
        if (s16 <= -32768) return -1;
        if (s16 >= 32767) return 1;
        return s16 / 32767;
      }
      function normTrig(u8) {
        return Math.max(0, Math.min(1, u8 / 255));
      }

      // D-pad bits
      const DPAD_UP = 0x00000001;
      const DPAD_DOWN = 0x00000002;
      const DPAD_LEFT = 0x00000004;
      const DPAD_RIGHT = 0x00000008;

      // Button bits
      const BTN_LB = 0x00000100;
      const BTN_RB = 0x00000200;
      const BTN_GUIDE = 0x00000400;
      const BTN_BACK = 0x00000020;
      const BTN_START = 0x00000010;
      const BTN_L3 = 0x00000040;
      const BTN_R3 = 0x00000080;

      const BTN_A = 0x00001000;
      const BTN_B = 0x00002000;
      const BTN_X = 0x00004000;
      const BTN_Y = 0x00008000;

      // u32 btn @ offset 2
      // lt @ 4, rt @ 5
      // lx @ 6, ly @ 8, rx @ 10, ry @ 12 (signed 16-bit)
      function decodeToState(report20) {
        const btn = u32le(report20, 2);

        const lt = report20[4];
        const rt = report20[5];

        const lx = s16le(report20, 6);
        const ly = s16le(report20, 8);
        const rx = s16le(report20, 10);
        const ry = s16le(report20, 12);

        return {
          buttons: {
            a: !!(btn & BTN_A),
            b: !!(btn & BTN_B),
            x: !!(btn & BTN_X),
            y: !!(btn & BTN_Y),

            lb: !!(btn & BTN_LB),
            rb: !!(btn & BTN_RB),

            start: !!(btn & BTN_START),
            back: !!(btn & BTN_BACK),

            ls: !!(btn & BTN_L3),
            rs: !!(btn & BTN_R3),

            up: !!(btn & DPAD_UP),
            down: !!(btn & DPAD_DOWN),
            left: !!(btn & DPAD_LEFT),
            right: !!(btn & DPAD_RIGHT),

            guide: !!(btn & BTN_GUIDE),
          },
          axes: {
            lx: normStick(lx),
            ly: normStick(ly),
            rx: normStick(rx),
            ry: normStick(ry),
            lt: normTrig(lt),
            rt: normTrig(rt),
          },
        };
      }

      // Simple poll-rate meter (updates ~2x/sec)
      let sampleCount = 0;
      let lastRateT = performance.now();
      function tickRate() {
        sampleCount++;
        const now = performance.now();
        if (now - lastRateT >= 500) {
          const hz = (sampleCount * 1000) / (now - lastRateT);
          rateEl.textContent = `Poll rate: ${hz.toFixed(1)} Hz`;
          sampleCount = 0;
          lastRateT = now;
        }
      }

      async function connectWebUSB() {
        try {
          dev = await navigator.usb.requestDevice({
            filters: [{ vendorId: VID, productId: PID }],
          });

          await dev.open();

          if (dev.configuration === null) {
            await dev.selectConfiguration(1);
          }

          await dev.claimInterface(USB_INTERFACE);

          // Enable: bmRequestType=0x40, bRequest=0x48, wValue=0x0002, wIndex=0
          await dev.controlTransferOut({
            requestType: "vendor",
            recipient: "device",
            request: 0x48,
            value: 0x0002,
            index: 0,
          });

          log("WebUSB: enabled.");
          document.getElementById("connect").disabled = true;
          document.getElementById("disconnect").disabled = false;

          if (!ws || ws.readyState !== WebSocket.OPEN) {
            log("WS: connecting...");
            connectWS();
          }

          running = true;
          log("Starting poll...");

          // Main poll loop:
          // - No fixed setTimeout sleep (timers get throttled)
          // - Drop frames when WS backs up (prevents erratic bursts)
          while (running) {
            const res = await dev.controlTransferIn(
              {
                requestType: "vendor",
                recipient: "device",
                request: 0xc2,
                value: 0x0000,
                index: 0,
              },
              20,
            );

            if (res.status !== "ok") {
              log("WebUSB read status: " + res.status);
              break;
            }

            const bytes = new Uint8Array(res.data.buffer);
            const state = decodeToState(bytes);

            renderState(state);
            tickRate();

            // Send decoded state to the local bridge (latest-only, drop-on-backpressure)
            wsSendLatest(state);

            // Tiny yield occasionally to keep UI responsive without relying on timers.
            if ((sampleCount & 0x3f) === 0) await Promise.resolve();
          }
        } catch (e) {
          log("Error: " + (e && e.message ? e.message : String(e)));
          cleanup();
        }
      }

      async function disconnectWebUSB() {
        running = false;

        try {
          if (dev) {
            try {
              await dev.releaseInterface(USB_INTERFACE);
            } catch {}
            try {
              await dev.close();
            } catch {}
          }
        } finally {
          dev = null;
          cleanup();
          log("WebUSB: disconnected.");
          liveLine.textContent = "";
          rateEl.textContent = "";
          statePre.textContent = "";
        }
      }

      function cleanup() {
        document.getElementById("connect").disabled = false;
        document.getElementById("disconnect").disabled = true;
      }

      document.getElementById("connect").onclick = connectWebUSB;
      document.getElementById("disconnect").onclick = disconnectWebUSB;

      navigator.usb.addEventListener("disconnect", (event) => {
        if (dev && event.device === dev) {
          log("WebUSB: device unplugged.");
          disconnectWebUSB();
        }
      });
    </script>
  </body>
</html>
